# Golang 基础梳理

## select是随机的还是顺序的?
答：select会随机选择一个可用通道做收发操作

## Go语言局部变量分配在栈还是堆
答：Go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。

```golang
package main

func foo(m0 int) (*int) {
  var m1 int = 11;
  return &m1 // 把m1的地址返回了，如果在栈空间的 它们会随着函数的返回把内存还给系统
}            // 申请到 栈内存 好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响。
             // 申请到堆上面的内存才会引起垃圾回收，如果这个过程（特指垃圾回收不断被触发）过于高频就会导致 gc 压力过大，程序性能出问题。
func main() {
  m := foo(100)
  println(*m)
}
```
go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。
申请后作为返回值返回了，编译器会认为变量之后还会被使用，当函数返回之后并不会将其内存归还，那么它就会被申请到 堆 上面
go语言声称这样可以释放程序员关于内存的使用限制，更多的让程序员关注于程序功能逻辑本身。一个函数内局部变量，不管是不是动态new出来的，它会被分配在堆还是栈，是由编译器做逃逸分析之后做出的决定

## 简述一下你对Go垃圾回收机制的理解
答：
- v1.1 STW
- v1.3 Mark STW, Sweep 并行
- v1.5 三色标记法
- v1.8 hybrid write barrier(混合写屏障：优化STW)
GC 算法：引用计数（reference counting）/ 标记-清扫（mark & sweep）/ 节点复制（Copying Garbage Collection）/ 分代收集（Generational Garbage Collection）

## 简述一下golang的协程调度原理
答：`不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存`
- M(machine): 代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。
- P(processor): 表示逻辑processor，是线程M的执行的上下文。
- G(goroutine): 调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。

三者关系:

每一个运行的M都必须绑定一个P,线程M创建后会去检查并执行G(goroutine)对象
每一个P保存着一个协程G的队列
除了每个P自身保存的G的队列外,调度器还拥有一个全局的G队列
M从队列中提取G,并执行
P的个数就是GOMAXPROCS(最大256),启动时固定的,一般不修改
M的个数和P的个数不一定一样多(会有休眠的M或P不绑定M) (最大10000)
P是用一个全局数组(255)来保存的,并且维护着一个全局的P空闲链表

## Golang内存分配逃逸分析
答：
https://driverzhang.github.io/post/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/
所谓逃逸分析（Escape analysis）是指由编译器决定内存分配的位置，不需要程序员指定。
在函数中申请一个新的对象：
- 如果分配 在栈中，则函数执行结束可自动将内存回收；
- 如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理;
- 对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力 [栈空间不足逃逸（空间开辟过大]

终端运行命令`go build -gcflags=-m`查看逃逸分析日志：

## 无缓冲 Chan 的发送和接收是否同步
答：
- channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。
- channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。

## Golang通过哪几种方式来实现并发控制,如何优雅的退出goroutine
答：
- chan 通过无缓冲通道来实现多 goroutine 并发控制
- 通过sync包中的WaitGroup 实现并发控制
- 使用for-range退出
- 使用,ok退出
- 使用退出通道退出

##  Golang的方法集

## Go程和协程的区别
本质上，goroutine 就是协程。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，
当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，
让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。
Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。

## Swoole4 协程与 Go 协程有哪些区别
答：
Swoole4的协程调度器是单线程的，因此不存在数据同步问题，同一时间只会有一个协程在运行
Go协程调度器是多线程的，同一时间可能会有多个协程同时执行
因此在Swoole4协程中操作全局变量是不需要加锁的。而Go的程序由于依然是类似Java的多线程模式，因此务必要对临界资源加锁，避免出现数据同步问题。或者使用官方sync包提供的各种并发容器。

实际上Go的chan和并发容器，底层仍然使用了Mutex进行锁操作，锁的争抢是普遍存在的。

Swoole4由于是单线程多进程的，底层没有使用任何Mutex锁，不存在锁的争抢。 同样带来的问题是，没有超全局变量。只有进程级全局变量，读写PHP全局变量只在当前进程内有效

## new与make
答：
- 内建函数make(T, args)与new(T)的用途不一样。它只用来创建slice，map和channel，并且返回一个初始化的(而不是置零)，类型为T的值（而不是*T）
- new 这是一个用来分配内存的内建函数，但是与C++不一样的是，它并不初始化内存，只是将其置为零值，并且返回一个指针


## Go的调度为什么说是轻量级的？

## Go的调度都发生了啥？

## Go的网络和锁会不会阻塞线程？

## 什么时候会阻塞线程？

## Go 的对象在内存中是怎样的？

## Go的内存分配是怎样的？

## 栈的内存分配是怎样的？

## GC是怎样的？

## GC怎么帮我们回收对象？

## GO的GC会不会漏掉对象或者回收还在用的对象？

## GO GC 什么时候开始

## GO GC 什么时候结束？

## GO GC 会不会太慢，跟不上内存分配的速度？

## GO GC 会不会暂停我们的应用？暂停多久？影不影响我们的请求？

